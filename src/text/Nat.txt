Œì ‚ä¶ ‚Ñï type

Œì ‚ä¶ Z : ‚Ñï

Œì ‚ä¶ n : ‚Ñï
------------
Œì ‚ä¶ S n : ‚Ñï

Œì (x : ‚Ñï) ‚ä¶ A type
Œì ‚ä¶ A(0/x)
Œì (x : ‚Ñï) (h : A) ‚ä¶ s : A(S x/x)
Œì ‚ä¶ t : ‚Ñï
---------------------------------
Œì ‚ä¶ ‚Ñï-elim x.A z x.h.s t : A(t/x)
Œì ‚ä¶ ‚Ñï-elim x.A z s Z = z
Œì ‚ä¶ ‚Ñï-elim A z s (S t) = s(t / x, ‚Ñï-elim x.A z x.h.s t / h)

//Œ∑-rule for ‚Ñï
‚Ñï-Œ∑ : (a‚ÇÄ : P 0)
      (a‚ÇÅ : (x : ‚Ñï) ‚Üí P x ‚Üí P (S x))
      (f : (x : ‚Ñï) ‚Üí P x)
      (z : f 0 ‚â° a‚ÇÄ)
      (s : (x : ‚Ñï) ‚Üí f (S x) ‚â° a‚ÇÅ x (f x) ‚àà P (S x))
      ‚Üí
      f ‚â° (x ‚Ü¶ ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x) ‚àà (x : ‚Ñï) ‚Üí P x
‚àé
//By function extensionality it's enough to show:
(x : ‚Ñï) ‚ä¶ f x ‚â° ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x ‚àà P x
//By induction on x
* f 0 ‚â° a‚ÇÄ ‚àà P 0 ‚úî
* (x : ‚Ñï) (H : f x ‚â° ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x) ‚ä¶
    f (S x) ‚â° ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) (S x)
    //By definition
    f (S x) ‚â° a‚ÇÅ x (‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x)
    //By induction hypothesis
    f (S x) ‚â° a‚ÇÅ x (f x) ‚úî ‚àé

//Pattern-matching principle for ‚Ñï
//i.e. for arbitrary function f the following two equations uniquely determine the function.
‚Ñï-pat : ((f : (x : ‚Ñï) ‚Üí P x) ‚®Ø (f 0 ‚â° a‚ÇÄ) ‚®Ø ((x : ‚Ñï) ‚Üí f (S x) ‚â° a‚ÇÅ x (f x))) ‚âÖ ùüô
‚Ñï-pat = (const (), const (x ‚Ü¶ ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x, Refl, Refl), Refl, Refl)
 where
  to : ((f : (x : ‚Ñï) ‚Üí P x) ‚®Ø (f 0 ‚â° a‚ÇÄ) ‚®Ø ((x : ‚Ñï) ‚Üí f (S x) ‚â° a‚ÇÅ x (f x))) ‚âÖ ùüô
  to = const ()

  from : ùüô ‚Üí ((f : (x : ‚Ñï) ‚Üí P x) ‚®Ø (f 0 ‚â° a‚ÇÄ) ‚®Ø ((x : ‚Ñï) ‚Üí f (S x) ‚â° a‚ÇÅ x (f x)))
  from = const (x ‚Ü¶ ‚Ñï-elim (x. P x) a‚ÇÄ (x.h. a‚ÇÅ x h) x, Refl, Refl)

  to ‚àò from ‚â° id //trivial

  from ‚àò to ‚â° id //true by ‚Ñï-Œ∑

‚Ñï-rec : (A : ùïå) (z : A) (s : A ‚Üí A) (t : ‚Ñï) ‚Üí A
‚Ñï-rec A z s 0 = z
‚Ñï-rec A z s (S t) = s (‚Ñï-rec A z s t)

‚Ñï-case : (P : ‚Ñï ‚Üí ùïå) (z : P 0) (s : (x : ‚Ñï) ‚Üí P (S x)) (n : ‚Ñï) ‚Üí P n
‚Ñï-case P z s 0 = z
‚Ñï-case P z s (S n) = s n

(x : ‚Ñï) (y : ‚Ñï) ‚ä¶ x + y : ‚Ñï
  0 + x = x ‚àà ‚Ñï
  S x + y = S (x + y) ‚àà ‚Ñï

lemma0 : (x y : ‚Ñï) ‚Üí x + S y ‚â° S x + y
lemma0 0 y = Refl
lemma0 (S x) y = cong S (lemma0 x y)

+-right-neutral : (x : ‚Ñï) ‚Üí x + 0 ‚â° x
+-right-neutral 0 = Refl
+-right-neutral (S x) = cong S (plus-right-neutral x)

+-commutative : (x y : ‚Ñï) ‚Üí x + y ‚â° y + x
+-commutative 0 y = plus-right-neutral y
+-commutative (S x) y = cong S (+-right-neutral x y) ‚àô (lemma0 y x)‚Åª¬π

// TODO: Associativity of addition
(x y z : ‚Ñï) ‚ä¶ +-associative x y z : x + (y + z) ‚â° (x + y) + z

// Define multiplication
_*_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
0 * n = 0
(S m) * n = n + m * n

*-distrib-over-add : (k x y : ‚Ñï) ‚Üí (x + y) * k ‚â° x * k + y * k
*-distrib-over-add 0 x y = Refl
 where
  (x + y) * 0
    ‚â°
  0
    ‚â°
  0 + 0
    ‚â°
  x * 0 + 0
    ‚â°
  x * 0 + y * 0

*-distrib-over-add (S k) = Refl : (x y : ‚Ñï) ‚Üí (x + y) * S k ‚â° x * S k + y * S k
  where
    (x y : ‚Ñï) ‚Üí (x + y) * S k ‚â° x * S k + y * S k
    ‚â°
    (x y : ‚Ñï) ‚Üí S k * (x + y) ‚â° S k * x + S k * y
    ‚â°
    (x y : ‚Ñï) ‚Üí (x + y) + k * (x + y) ‚â° x + k * x + y + k * y
    ‚â°
    (x y : ‚Ñï) ‚Üí (x + y) + (x + y) * k ‚â° x + x * k + y + y * k
    ‚â°
    (x y : ‚Ñï) ‚Üí (x + y) + (x + y) * k ‚â° (x + y) + (x * k + y * k)
    ‚â°
    (x y : ‚Ñï) ‚Üí (x + y) + (x + y) * k ‚â° (x + y) + (x + y) * k
    ‚âÖ
    ùüô

//Multiplication distributes over addition on the left
(x y k : ‚Ñï) ‚ä¶ k * (x + y) ‚â° k * x + k * x
‚àé
//By commutativity of multiplication
(x y k : ‚Ñï) ‚ä¶ (x + y) * k ‚â° x * k + x * k
//By "Multiplication distributes over addition on the right" ‚àé

//Define
0 ‚âî Z
1 ‚âî S 0

// Left multiplicative identity
(x : ‚Ñï) ‚ä¶ 1 * x ‚â° x
‚àé
(x : ‚Ñï) ‚ä¶ 1 * x
           = // By computation
          x + 0 * x
           = // By computation
          x + 0
           = // By right additive identity
          x : ‚Ñï ‚àé

// Right multiplicative annihilation
(x : ‚Ñï) ‚ä¶ x * 0 ‚â° 0
‚àé
//By induction on x
* 0 * 0 ‚â° 0
  <=> //By computation
  0 ‚â° 0
* (x : ‚Ñï) (x * 0 ‚â° 0) ‚ä¶ S x * 0 ‚â° 0
  <=> //By computation
  (x : ‚Ñï) (x * 0 ‚â° 0) ‚ä¶ 0 + x * 0 ‚â° 0
  <=> //By computation
  (x : ‚Ñï) (x * 0 ‚â° 0) ‚ä¶ x * 0 ‚â° 0
  <=> By inductive hypothesis
  (x : ‚Ñï) (x * 0 ‚â° 0) ‚ä¶ 0 ‚â° 0

//lemma2
(x y : ‚Ñï) ‚ä¶ y * S x ‚â° y + y * x
‚àé
// By induction on y
* 0 * S x ‚â° 0 + 0 * x
  <=> // By computation
  0 ‚â° 0
* ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S y * S x ‚â° S y + S y * x
  <=> // By computation
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = S y + (x + y * x)
  <=> // By associativity of addition
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = (S y + x) + y * x
  <=> // By lemma0
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = (y + S x) + y * x
  <=> // By commutativity of addition
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = (S x + y) + y * x
  <=> // By associativity of addition
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = S x + (y + y * x)
  <=> // By induction hypothesis
  ((x : ‚Ñï) ‚ä¶ y * S x = y + y * x) ‚ä¶ S x + y * S x = S x + y * S x
‚àé

// Commutativity of multiplication
(x : ‚Ñï) ‚ä¶ (y : ‚Ñï) ‚ä¶ x * y ‚â° y * x
‚àé
//By induction on x
* (x : ‚Ñï) ‚ä¶ (y : ‚Ñï) ‚ä¶ 0 * y ‚â° y * 0
  <=> // By computation
  (x : ‚Ñï) ‚ä¶ (y : ‚Ñï) ‚ä¶ 0 ‚â° y * 0
  <=> // By right multiplicative annihilation
  (x : ‚Ñï) ‚ä¶ (y : ‚Ñï) ‚ä¶ 0 ‚â° 0
* (x : ‚Ñï) ((y : ‚Ñï) ‚ä¶ x * y ‚â° y * x) ‚ä¶ (y : ‚Ñï) ‚ä¶ S x * y ‚â° y * S x
  <=> // By computation
  (x : ‚Ñï) ((y : ‚Ñï) ‚ä¶ x * y ‚â° y * x) ‚ä¶ (y : ‚Ñï) ‚ä¶ y + x * y ‚â° y * S x
  <=> // By lemma2
  (x : ‚Ñï) ((y : ‚Ñï) ‚ä¶ x * y ‚â° y * x) ‚ä¶ (y : ‚Ñï) ‚ä¶ y + x * y ‚â° y + y * x
  <=> // By induction hypothesis
  (x : ‚Ñï) ((y : ‚Ñï) ‚ä¶ x * y ‚â° y * x) ‚ä¶ (y : ‚Ñï) ‚ä¶ y + x * y ‚â° y + x * y
‚àé

// Division relation
//TODO: do we actually want to truncate?
(k : ‚Ñï) (d : ‚Ñï) (d ‚â¢ 0) ‚ä¶ (k | d) ‚âî ‚àÉ(n : ‚Ñï) (n * k ‚â° d) : ùïå


// 1 divides every number
(d : ‚Ñï) ‚ä¶ 1 | d
‚àé
// By definition
(d : ‚Ñï) ‚ä¶ ‚Äñ(n : ‚Ñï) ‚®Ø n * 1 ‚â° d‚Äñ
//It's enough to provide
(d : ‚Ñï) ‚ä¶ (n : ‚Ñï) ‚®Ø n * 1 ‚â° d
// pick n ‚âî d
(d : ‚Ñï) ‚ä¶ d * 1 ‚â° d
//By right multiplicative unit law ‚àé


// Division relation is transitive
(a b c : ‚Ñï) (b ‚â¢ 0) (c ‚â¢ 0) (a | b) (b | c) ‚ä¶ a | c
‚àé
//By definition
(a b c : ‚Ñï) ‚Äñ(m : ‚Ñï) ‚®Ø m * a ‚â° b‚Äñ ‚Äñ(n : ‚Ñï) ‚®Ø n * b ‚â° c‚Äñ ‚ä¶ a | c
// The target type is a mere proposition so it's enough to construct
(a b c : ‚Ñï) ‚Äñ(m : ‚Ñï) ‚®Ø m * a ‚â° b‚Äñ ((n : ‚Ñï) ‚®Ø n * b ‚â° c) ‚ä¶ a | c
// The target type is a mere proposition so it's enough to construct
(a b c : ‚Ñï) ((m : ‚Ñï) ‚®Ø m * a ‚â° b) ((n : ‚Ñï) ‚®Ø n * b ‚â° c) ‚ä¶ a | c
//By expanding out Œ£-types
(a b c : ‚Ñï) (m n : ‚Ñï) (m * a ‚â° b) (n * b ‚â° c) ‚ä¶ a | c
//By applying n * b ‚â° c
(a b c : ‚Ñï) (m n : ‚Ñï) (m * a ‚â° b) ‚ä¶ a | n * b
//By applying m * a ‚â° b
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ a | n * (m * a)
//By associativity of multiplication
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ a | (n * m) * a
//By definition
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ ‚Äñ(k : ‚Ñï) ‚®Ø k * a ‚â° (n * m) * a‚Äñ
//It's enough to construct
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ (k : ‚Ñï) ‚®Ø k * a ‚â° (n * m) * a
//Expanding out Œ£
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ k : ‚Ñï
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ k * a = (n * m) * a
//Take k ‚âî n * m
(a b c : ‚Ñï) (m n : ‚Ñï) ‚ä¶ (n * m) * a = (n * m) * a
‚àé

m n : ‚Ñï
---------
m ‚â§ n type

n : ‚Ñï
---------------
LteRefl : n ‚â§ n

m n : ‚Ñï
p : m ‚â§ n
------------------
LteSuc p : m ‚â§ S n

(m n : ‚Ñï) (p : m ‚â§ n) ‚ä¶ A type
(n : ‚Ñï) ‚ä¶ z : A(n/m, LteRefl)
(m n : ‚Ñï) (p : m ‚â§ n) ‚ä¶ s : A ‚Üí A(m, S n, LteSuc p)
---------------------------------------------------
(m n : ‚Ñï) (p : m ‚â§ n) ‚ä¶ ‚â§-elim z s : A
(m : ‚Ñï) ‚ä¶ (‚â§-elim z s)(m, m, LteRefl) = z : A(m, m, LteRefl)
(m n : ‚Ñï) (p : m ‚â§ n) ‚ä¶ (‚â§-elim z s)(m, S n, LteSuc p) = s(m, n, p) (‚â§-elim z s) : A(m, S n, LteSuc p)

//0-initial-‚â§
0-initial-‚â§ : (m : ‚Ñï) ‚Üí 0 ‚â§ m
0-initial-‚â§ 0 = LteRefl
0-initial-‚â§ (S m) = LteSuc (0-initial-‚â§ m)

//Define observational equality on ‚Ñï
_~_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ùïå
0 ~ 0 = ùüô
0 ~ S n = ùüò
S m ~ 0 = ùüò
S m ~ S n = m ~ n

//Observational equality on ‚Ñï is reflexive
Refl : (m : ‚Ñï) ‚Üí m ~ m
Refl 0 = ()
Refl (S m) = Refl m

‚Ñï-int : (m n : ‚Ñï) ‚Üí m ~ n ‚Üí m ‚â° n
‚Ñï-int 0 0 () = Refl
‚Ñï-int (S m) 0 contra = absurd contra
‚Ñï-int 0 (S n) contra = absurd contra
‚Ñï-int (S m) (S n) p = cong S (‚Ñï-int m n p)

‚Ñï-ext : (m n : ‚Ñï) ‚Üí m ‚â° n ‚Üí m ~ n
‚Ñï-ext m m Refl = Refl m

S-not-0 : (m : ‚Ñï) ‚Üí S m ‚â¢ 0
S-not-0 m contra = H m (‚Ñï-ext _ _ contra)
  where
   H : (m : ‚Ñï) ‚Üí S m ~ 0 ‚Üí ùüò
   H m p = p

pred-‚â° : (m n : ‚Ñï) (p : S m ‚â° S n) ‚Üí m ‚â° n
pred-‚â° m n p = cong pred p

S-not-smaller-than-0 : (m : ‚Ñï) ‚Üí ¬¨(S m ‚â§ 0)
S-not-smaller-than-0 _ _ impossible

0-smallest : (m : ‚Ñï) ‚Üí (m ‚â§ 0) ‚Üí m ‚â° 0
0-smallest 0 _ = Refl

‚â§-+ : (m n : ‚Ñï) ‚Üí (m ‚â§ n + m)
‚â§-+ m 0 = LteRefl
‚â§-+ m (S n) = LteSuc (‚â§-+ m n)

pred-‚â§ : (m n : ‚Ñï) (p : S m ‚â§ S n) ‚Üí m ‚â§ n
pred-‚â§ m m LteRefl = Refl
pred-‚â§ m (S n) (LteSuc p) = LteSuc (pred-‚â§ m n p)

S-‚â§ : (m n : ‚Ñï) (p : m ‚â§ n) ‚Üí S m ‚â§ S n
S-‚â§ m m LteRefl = LteRefl
S-‚â§ m (S n) (LteSuc p) = LteSuc (S-‚â§ m n p)

‚â§-eq : (m n : ‚Ñï) (p : m ‚â§ n) ‚Üí (x : ‚Ñï) ‚®Ø (n ‚â° x + m)
‚â§-eq 0 n _ = (n, Refl)
‚â§-eq (S m) 0 (p : S m ‚â§ 0) = absurd (S-not-smaller-than-0 _ p)
‚â§-eq (S m) (S n) (p : S m ‚â§ S n) = ‚â§-eq m n (pred-‚â§ p)

‚â§-trans : (m n k : ‚Ñï) (m ‚â§ n) (n ‚â§ k) ‚Üí m ‚â§ k
‚â§-trans m m k LteRefl q = q
‚â§-trans m n n p LteRefl = p
‚â§-trans m n (S k) p (LteSuc q) = LteSuc (‚â§-trans m n k p q)

//‚â¢-sym
(a b : X) ‚ä¶ a ‚â¢ b ‚Üí b ‚â¢ a
‚àé
(a b : X) (a ‚â¢ b) ‚ä¶ b ‚â¢ a
(a b : X) (a ‚â° b ‚Üí ùüò) ‚ä¶ b ‚â° a ‚Üí ùüò
(a : X) (a ‚â° a ‚Üí ùüò) ‚ä¶ ùüò
(a : X) ùüò ‚ä¶ ùüò ‚àé

//S-‚â¢
(n m : ‚Ñï) ‚ä¶ n ‚â¢ m ‚Üí S n ‚â¢ S m
‚àé
(n m : ‚Ñï) ‚ä¶ n ‚â¢ m ‚Üí S n ‚â° S m ‚Üí ùüò
(n m : ‚Ñï) ‚ä¶ n ‚â¢ m ‚Üí n ‚â° m ‚Üí ùüò
(n m : ‚Ñï) ‚ä¶ n ‚â¢ m ‚Üí n ‚â¢ m ‚àé

//Two non-zero natural numbers are relatively prime (coprime) if there exists no common divisor other than 1
(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ‚ä¶ Comprime a b ‚âî ¬¨((n : ‚Ñï) ‚®Ø n ‚â† 1 ‚®Ø (n | a) ‚®Ø (n | b)) : ùïå


//Lemma S-X-not-‚â§-X
(m : ‚Ñï) ‚ä¶ ¬¨(S m ‚â§ m)
‚àé
//Via ‚â§-eq we have
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° S m + k) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° (1 + m) + k) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° 1 + (m + k)) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° 1 + (k + m)) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° (1 + k) + m) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (m ‚â° S k + m) ‚Üí ùüò
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (0 + m ‚â° (S k) + m) ‚Üí ùüò
//By right cancellation law
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (0 ‚â° S k) ‚Üí ùüò
//‚â°-sym
(m : ‚Ñï) (k : ‚Ñï) ‚ä¶ (S k ‚â° 0) ‚Üí ùüò
//By S-not-0 ‚àé

LteDiagUnique : (m : ‚Ñï) (p : m ‚â§ m) ‚Üí p ‚â° LteRefl
LteDiagUnique m LteRefl = Refl

LteUnique : (m n : ‚Ñï) (p q : m ‚â§ n) ‚Üí p ‚â° q
LteUnique m m p LteRefl = LteDiagUnique m p
LteUnique (S n) (S n) Refl (LteSuc q) = //absurd by q
  // q : S n ‚â§ n
LteUnique m (S n) (LteSuc p) (LteSuc q) = cong LteSuc (LteUnique m n p q)

//Define
(m n : ‚Ñï) ‚ä¶ (m < n) ‚âî (m ‚â§ n) ‚®Ø (m ‚â† n)

//S-<
(m n : ‚Ñï) (m < n) ‚ä¶ S m < S n
‚àé
(m n : ‚Ñï) (m ‚â§ n) (m ‚â¢ n) ‚ä¶ S m ‚â§ S n ‚®Ø S m ‚â† S n
//Fill in the first componenent of the pair by S-‚â§
(m n : ‚Ñï) (m ‚â§ n) (m ‚â¢ n) ‚ä¶ S m ‚â† S n
//By S-‚â¢ ‚àé

//pred-‚â¢
(m n : ‚Ñï) (S m ‚â¢ S n) ‚ä¶ m ‚â¢ n
‚àé
//By definition
(m n : ‚Ñï) (S m ‚â¢ S n) ‚ä¶ m ‚â° n ‚Üí ùüò
//Apply congruence to m ‚â° n
(m n : ‚Ñï) (S m ‚â¢ S n) ‚ä¶ S m ‚â° S n ‚Üí ùüò
//By definition
(m n : ‚Ñï) (S m ‚â¢ S n) ‚ä¶ S m ‚â¢ S n
//Trivial ‚àé


//pred-<
(m n : ‚Ñï) (S m < S n) ‚ä¶ m < n
‚àé
//By definition
(m n : ‚Ñï) ((S m ‚â§ S n) ‚®Ø S m ‚â¢ S n) ‚ä¶ (m ‚â§ n) ‚®Ø (m ‚â¢ n)
//Apply pred-‚â§, pred-‚â¢
(m n : ‚Ñï) ((m ‚â§ n) ‚®Ø m ‚â¢ n) ‚ä¶ (m ‚â§ n) ‚®Ø (m ‚â¢ n)
//Trivial ‚àé

//S->
(m n : ‚Ñï) (m > n) ‚ä¶ S m > S n
‚àé
(m n : ‚Ñï) (n < m) ‚ä¶ S n < S m
//By S-< ‚àé

//Define
(m n : ‚Ñï) ‚ä¶ (m > n) ‚âî (n < m)

TODO: Show that (<) is a mere proposition for every pair (m, n)

‚â§-dec : (m n : ‚Ñï) ‚Üí (m ‚â§ n) ‚à™ (m > n)
‚â§-dec 0 n = Left (0-initial-‚â§ _)
‚â§-dec (S m) 0 = Right (0-initial-‚â§ _, (S-not-0 _)‚Åª¬π) : (S m ‚â§ 0) ‚à™ (0 < S m)
‚â§-dec (S m) (S n) = bimap S-‚â§ S-< (‚â§-dec m n)

0-is-the-only-<-1 : (k : ‚Ñï) ‚Üí k < 1 ‚Üí k ‚â° 0
0-is-the-only-<-1 0 _ = Refl
0-is-the-only-<-1 (S k) ((p, q) : (S k ‚â§ S 0) ‚®Ø (S k ‚â¢ S 0)) = //contradiction
  // S k ‚â¢ S 0        ‚áí k ‚â¢ 0
  //S k ‚â§ S 0 ‚áí k ‚â§ 0 ‚áí k ‚â° 0

(m n : ‚Ñï) (p q : (m < n) ‚à™ (m ‚â° n)) ‚ä¶ p ‚â° q
‚àé
//By induction on p
* (m n : ‚Ñï) (p : m < n) (q : (m < n) ‚à™ (m ‚â° n)) ‚ä¶ Left p ‚â° q
  //By induction on q
  * (m n : ‚Ñï) (p : m < n) (q : m < n) ‚ä¶ Left p ‚â° Left q
    // (m < n) is a mere proposition, hence:
  * (m n : ‚Ñï) (p : m < n) (q : m < n) (p ‚â° q) ‚ä¶ Left p ‚â° Left q
    //Contract q
  * (m n : ‚Ñï) (p : m < n) ‚ä¶ Left p ‚â° Left p
    //Trivial
  * (m n : ‚Ñï) (p : m < n) (q : m ‚â° n) ‚ä¶ Left p ‚â° Right q
    //Contract n
    (m n : ‚Ñï) (p : m < m) ‚ä¶ Left p ‚â° Right q
    //By definition
    (m n : ‚Ñï) (p : (m ‚â§ m) ‚®Ø (m ‚â¢ m)) ‚ä¶ Left p ‚â° Right q
    //Contraction in p
* (m n : ‚Ñï) (p : m ‚â° n) (q : (m < n) ‚à™ (m ‚â° n)) ‚ä¶ Right p ‚â° q
  //By induction on q
  * (m n : ‚Ñï) (p : m ‚â° n) (q : m < n) ‚ä¶ Right p ‚â° Left q
    //Contract n
    (m : ‚Ñï) (q : m < m) ‚ä¶ Right p ‚â° Left q
    //By definition
    (m : ‚Ñï) (q : (m ‚â§ m) ‚®Ø (m ‚â¢ m)) ‚ä¶ Right p ‚â° Left q
    //Contraction in q
  * (m n : ‚Ñï) (p : m ‚â° n) (q : m ‚â° n) ‚ä¶ Right p ‚â° Right q
    //Contract n via q
    (m : ‚Ñï) (p : m ‚â° m) ‚ä¶ Right p ‚â° Right *
    //Via UIP
    (m : ‚Ñï) ‚ä¶ Right * ‚â° Right *
    //Trivial ‚àé

//Lemma
(m n : ‚Ñï) ‚ä¶ m ‚â§ n ‚âÉ (m < n) ‚à™ (m ‚â° n)
‚àé
//Both sides are mere propositions so it's enough to show
* (m n : ‚Ñï) ‚ä¶ m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)
  //By induction on m
  * (n : ‚Ñï) ‚ä¶ 0 ‚â§ n ‚Üí (0 < n) ‚à™ (0 ‚â° n)
    //Throw away useless hypothesis
    (n : ‚Ñï) ‚ä¶ (0 < n) ‚à™ (0 ‚â° n)
    //By case-splitting on n
    * (0 < 0) ‚à™ (0 ‚â° 0)
      //Choose right
      0 ‚â° 0
      //By reflexivity
    * (n : ‚Ñï) ‚ä¶ (0 < S n) ‚à™ (0 ‚â° S n)
      //Choose left
      (n : ‚Ñï) ‚ä¶ 0 < S n
      //By definition
      (n : ‚Ñï) ‚ä¶ (0 ‚â§ S n) ‚®Ø (0 ‚â¢ S n)
      //Split
      * (n : ‚Ñï) ‚ä¶ 0 ‚â§ S n
        //By 0-initial-‚â§
      * (n : ‚Ñï) ‚ä¶ 0 ‚â¢ S n
        //‚â¢-sym
      * (n : ‚Ñï) ‚ä¶ S n ‚â¢ 0
        //By S-not-0
  * (m n : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ‚ä¶ S m ‚â§ n ‚Üí (S m < n) ‚à™ (S m ‚â° n)
    //By induction on n
    * (m : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ‚ä¶ S m ‚â§ 0 ‚Üí (S m < 0) ‚à™ (S m ‚â° 0)
      //Contradiction by S-not-smaller-than-0
    * (m n : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ((m : ‚Ñï) ‚ä¶ S m ‚â§ n ‚Üí (S m < n) ‚à™ (S m ‚â° n)) ‚ä¶
        S m ‚â§ S n ‚Üí (S m < S n) ‚à™ (S m ‚â° S n)
      //By pred-‚â§
      (m n : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ((m : ‚Ñï) ‚ä¶ S m ‚â§ n ‚Üí (S m < n) ‚à™ (S m ‚â° n)) ‚ä¶
        m ‚â§ n ‚Üí (S m < S n) ‚à™ (S m ‚â° S n)
      //By pred-‚â°
      (m n : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ((m : ‚Ñï) ‚ä¶ S m ‚â§ n ‚Üí (S m < n) ‚à™ (S m ‚â° n)) ‚ä¶
        m ‚â§ n ‚Üí (S m < S n) ‚à™ (m ‚â° n)
      //By pred-<
      (m n : ‚Ñï) ((n : ‚Ñï) ‚Üí m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)) ((m : ‚Ñï) ‚ä¶ S m ‚â§ n ‚Üí (S m < n) ‚à™ (S m ‚â° n)) ‚ä¶
        m ‚â§ n ‚Üí (m < n) ‚à™ (m ‚â° n)
      //Apply first inductive hypothesis at n ‚âî n ‚àé
* (m n : ‚Ñï) ‚ä¶ (m < n) ‚à™ (m ‚â° n) ‚Üí m ‚â§ n
  //Case-split
  * (m n : ‚Ñï) ‚ä¶ (m < n) ‚Üí (m ‚â§ n)
    //By definition
    (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚®Ø (m ‚â¢ n) ‚Üí (m ‚â§ n)
    //Take first projection
  * (m n : ‚Ñï) ‚ä¶ (m ‚â° n) ‚Üí (m ‚â§ n)
    //Contract n
    (m : ‚Ñï) ‚ä¶ (m ‚â§ m)
    //By reflexivity ‚àé

//Lemma
(m n : ‚Ñï) ‚ä¶ (m < S n) ‚âÉ (m ‚â§ n)
‚àé
//Both sides of the equivalence are mere propositions so it's enough to show:
* (m n : ‚Ñï) ‚ä¶ (m < S n) ‚Üí (m ‚â§ n)
  //By definition
  (m n : ‚Ñï) ‚ä¶ (m ‚â§ S n) ‚®Ø (m ‚â¢ S n) ‚Üí (m ‚â§ n)
  //Generalise (m ‚â§ S n)
  (m n q : ‚Ñï) ‚ä¶ (m ‚â§ q) ‚®Ø (q ‚â° S n) ‚®Ø (m ‚â¢ S n) ‚Üí (m ‚â§ n)
  //Reorder
  (m n q : ‚Ñï) (m ‚â¢ S n) (m ‚â§ q) ‚ä¶ (q ‚â° S n) ‚Üí (m ‚â§ n)
  //We can induct on (m ‚â§ q) because the target is a mere proposition
  * (m n : ‚Ñï) (m ‚â¢ S n) ‚ä¶ (m ‚â° S n) ‚Üí (m ‚â§ n)
    //Contradiction by (m ‚â¢ S n) and (m ‚â° S n)
  * (m n q : ‚Ñï) (m ‚â¢ S n) (m ‚â§ q) ‚ä¶ ((q ‚â° S n) ‚Üí (m ‚â§ n)) ‚Üí (S q ‚â° S n) ‚Üí (m ‚â§ n)
    //Apply pred-‚â°
    (m n q : ‚Ñï) (m ‚â¢ S n) (m ‚â§ q) ‚ä¶ ((q ‚â° S n) ‚Üí (m ‚â§ n)) ‚Üí (q ‚â° n) ‚Üí (m ‚â§ n)
    //Contract q
    (m n : ‚Ñï) (m ‚â¢ S n) (m ‚â§ n) ‚ä¶ ((n ‚â° S n) ‚Üí (m ‚â§ n)) ‚Üí (m ‚â§ n)
    //Trivial
* (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚Üí (m < S n)
  //By definition
  (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚Üí (m ‚â§ S n) ‚®Ø m ‚â¢ S n
  //Split
  * (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚Üí (m ‚â§ S n)
    //By transivity: m ‚â§ n ‚â§ S n
  * (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚Üí (m ‚â¢ S n)
    //By definition
    (m n : ‚Ñï) ‚ä¶ (m ‚â§ n) ‚Üí (m ‚â° S n) ‚Üí ùüò
    //Contract m
    (n : ‚Ñï) ‚ä¶ (S n ‚â§ n) ‚Üí ùüò
    //Using drop
    (n : ‚Ñï) ‚ä¶ (n ‚â° S n + k) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (n ‚â° (1 + n) + k) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (n ‚â° 1 + (n + k)) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (n ‚â° 1 + (k + n)) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (n ‚â° (1 + k) + n) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (0 + n ‚â° (1 + k) + n) ‚Üí ùüò
    //By right cancellation law
    (n : ‚Ñï) ‚ä¶ (0 ‚â° (1 + k)) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (0 ‚â° S k) ‚Üí ùüò
    (n : ‚Ñï) ‚ä¶ (S k ‚â° 0) ‚Üí ùüò
    //By S-not-0 ‚àé

//Lemma
(m : ‚Ñï) ‚ä¶ m ‚â¢ S m
‚àé
(m : ‚Ñï) ‚ä¶ (m ‚â° S m) ‚Üí ùüò
(m : ‚Ñï) ‚ä¶ (0 + m ‚â° 1 + m) ‚Üí ùüò
//By right cancellation law
(m : ‚Ñï) ‚ä¶ (0 ‚â° 1) ‚Üí ùüò
(m : ‚Ñï) ‚ä¶ (1 ‚â° 0) ‚Üí ùüò
//By S-not-0 ‚àé

//Lemma
(m : ‚Ñï) ‚ä¶ m < S m
‚àé
//By definition
(m : ‚Ñï) ‚ä¶ (m ‚â§ S m) ‚®Ø (m ‚â¢ S m)
//Split
* (m : ‚Ñï) ‚ä¶ m ‚â§ S m
  //By LteSuc LteRefl
* (m : ‚Ñï) ‚ä¶ m ‚â¢ S m
  //By lemma ‚àé

Next : x < S x
‚àé
//by definition it's enough to show
(x ‚â§ S x) ‚®Ø (x ‚â¢ S x)
//Split
* (x ‚â§ S x)
  //Solve by LteSuc LteRefl
* (x ‚â¢ S x)
  //By one of the lemmas ‚àé

Suc : x < y ‚Üí x < S y
‚àé
//It's enough to show
(p : x < y) ‚ä¶ x < S y
//Which is the same as
(p : x ‚â§ y) (q : x ‚â¢ y) ‚ä¶ (x ‚â§ S y) ‚®Ø (x ‚â¢ S y)
//Split
* (p : x ‚â§ y) (q : x ‚â¢ y) ‚ä¶ x ‚â§ S y
  //Solve by LteSuc p
* (p : x ‚â§ y) (q : x ‚â¢ y) ‚ä¶ x ‚â¢ S y
  //By definition
  (p : x ‚â§ y) (q : x ‚â¢ y) (l : x ‚â° S y) ‚ä¶ ùüò
  //Contract x
  (p : S y ‚â§ y) (q : S y ‚â¢ y) ‚ä¶ ùüò
  //Drop
  (p : S y ‚â§ y) ‚ä¶ ùüò
  //True By one of the lemmas ‚àé

//(Next, Suc) forms a covering, in a sense that
//to write functions out of (<) it's enough to consider the case of Next and Suc

P : ‚àÄ x y ‚Üí (x < y) ‚Üí ùïå
next : P x (S x) Next
suc : ‚àÄ x y ‚Üí (p : x < y) ‚Üí P x y p ‚Üí P x (S y) (Suc p)
-------------------------------------------------------
f : ‚àÄ x y ‚Üí (p : x < y) ‚Üí P x y p          }
f x (S x) Next = next                      } ‚âÖ ùüô
f x (S y) (Suc p) = suc x y p (f x y p)    }

f x 0 (p : x < 0) = absurd p
f x (S y) (LteSuc (p : x ‚â§ y), q : x ‚â¢ S y) with (to-< p)
 f x (S y) (LteSuc (p : x ‚â§ y), q : x ‚â¢ S y) | (Left (p' : x < y)) = suc x y p' (f x y p') : P x (S y) (LteSuc p, q)
 f x (S x) (LteSuc (p : x ‚â§ S x), q : x ‚â¢ S x) | (Right Refl) = Next : P x (S x) (LteSuc p, q)

-- P : ‚Ñï ‚Üí ùïå
-- a‚ÇÄ : (k : ‚Ñï) ‚Üí P k ‚Üí P (2 * k)
-- a‚ÇÅ : (k : ‚Ñï) ‚Üí P k ‚Üí P (2 * k + 1)
-- ---------------------------------------
-- f : (x : ‚Ñï) ‚Üí P x                   }
-- f (2 * k)     = a‚ÇÄ k (f k)          } ‚âÖ ùüô
-- f (2 * k + 1) = a‚ÇÅ k (f k)          }

-- (x < y) ‚âÖ (x ‚â§ y) ‚®Ø (x ‚â¢ y)
-- ‚Ñï‚ÇÅ ‚âÖ ‚Ñï‚ÇÇ


well-foundedH : (P : ‚Ñï ‚Üí ùïå)
                ((m : ‚Ñï) ‚Üí ((k : ‚Ñï) ‚Üí k < m ‚Üí P k) ‚Üí P m)
                (m k : ‚Ñï)
                (k < m)
                ‚Üí
                P k
well-foundedH P f 0 k p impossible
well-foundedH P f (S m) m Next = f m (well-foundedH P f m) : P m
well-foundedH P f (S m) k (Suc p) = well-foundedH P f m k p

well-founded : (P : ‚Ñï ‚Üí ùïå)
               ((m : ‚Ñï) ‚Üí ((k : ‚Ñï) ‚Üí k < m ‚Üí P k) ‚Üí P m)
               (x : ‚Ñï)
               ‚Üí
               P x
well-founded P f x = f x (well-foundedH P f x)


//Fibonacci sequence
(x : ‚Ñï) ‚ä¶ fib(x) : ‚Ñï
‚àé
//By well-founded induction on x
(x : ‚Ñï) ((k : ‚Ñï) ‚Üí k < x ‚Üí fib(k) : ‚Ñï) ‚ä¶ fib(x) : ‚Ñï
//By case-splitting on x
* ((k : ‚Ñï) ‚Üí k < 0 ‚Üí fib(k) : ‚Ñï) ‚ä¶ fib(0) ‚âî 0 : ‚Ñï
* (x : ‚Ñï) ((k : ‚Ñï) ‚Üí k < S x ‚Üí fib(k) : ‚Ñï) ‚ä¶ fib(S x) : ‚Ñï
  //By case-splitting on x
  * ((k : ‚Ñï) ‚Üí k < 1 ‚Üí fib(k) : ‚Ñï) ‚ä¶ fib(1) ‚âî 1 : ‚Ñï
  * (x : ‚Ñï) ((k : ‚Ñï) ‚Üí k < S (S x) ‚Üí fib(k) : ‚Ñï) ‚ä¶ fib(S (S x)) ‚âî fib(S x) + fib(x) : ‚Ñï ‚àé

//One can show that the fibonacci sequence satisfies the following properties:
fib(0) = 0
fib(1) = 1
fib(2 + x) = fib(1 + x) + fib(x)

//Moreover, fib(x) is uniquely determined by the equations above


(x : ‚Ñï) (x ‚â¢ 0) ‚ä¶ (y : ‚Ñï) ‚®Ø (x ‚â° S y)
‚àé
//Case-splitting on x
* (0 ‚â¢ 0) ‚ä¶ (y : ‚Ñï) ‚®Ø (0 ‚â° S y)
  //Contradiction
* (x : ‚Ñï) (S x ‚â¢ 0) ‚ä¶ (y : ‚Ñï) ‚®Ø (S x ‚â° S y)
  //Split
  * (x : ‚Ñï) (S x ‚â¢ 0) ‚ä¶ y : ‚Ñï
    //Take y ‚âî x
  * (x : ‚Ñï) (S x ‚â¢ 0) ‚ä¶ S x ‚â° S y
    (x : ‚Ñï) (S x ‚â¢ 0) ‚ä¶ S x ‚â° S x
    //Trivial ‚àé


//Right-cancellation law
(x y k : ‚Ñï) ‚ä¶ (x + k ‚â° y + k) ‚âÉ (x ‚â° y)
‚àé
//Both sides are mere propositions so it's enough to show:
* (x y k : ‚Ñï) ‚ä¶ (x + k ‚â° y + k) ‚Üí (x ‚â° y)
  //By induction on k
  * (x y : ‚Ñï) ‚ä¶ (x + 0 ‚â° y + 0) ‚Üí (x ‚â° y)
    //By commutativity
    (x y : ‚Ñï) ‚ä¶ (0 + x ‚â° 0 + y) ‚Üí (x ‚â° y)
    //By definition
    (x y : ‚Ñï) ‚ä¶ (x ‚â° y) ‚Üí (x ‚â° y)
    //Trivial
  * (x y k : ‚Ñï) ((x + k ‚â° y + k) ‚Üí (x ‚â° y)) ‚ä¶ (x + S k ‚â° y + S k) ‚Üí (x ‚â° y)
    //By lemma: (S x + y) = (x + S y)
    (x y k : ‚Ñï) ((x + k ‚â° y + k) ‚Üí (x ‚â° y)) ‚ä¶ (S x + k ‚â° S y + k) ‚Üí (x ‚â° y)
    //By definition
    (x y k : ‚Ñï) ((x + k ‚â° y + k) ‚Üí (x ‚â° y)) ‚ä¶ (S (x + k) ‚â° S (y + k)) ‚Üí (x ‚â° y)
    //By pred-‚â°
    (x y k : ‚Ñï) ((x + k ‚â° y + k) ‚Üí (x ‚â° y)) ‚ä¶ (x + k ‚â° y + k) ‚Üí (x ‚â° y)
    //Trivial
* (x y k : ‚Ñï) ‚ä¶ (x ‚â° y) ‚Üí (x + k ‚â° y + k)
  Applying congruence (+ k) ‚àé

//Left-cancellation law
(x y k : ‚Ñï) ‚ä¶ (k + x ‚â° k + y) ‚âÉ (x ‚â° y)
‚àé By applying commutativity to right-cancellation law ‚àé

(d : ‚Ñï) (n : ‚Ñï) (n ‚â¢ 0) ‚ä¶ d / n : ‚Ñï
‚àé
//By well-founded induction on d
(d m n : ‚Ñï) (n ‚â¢ 0) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
//By <-dec m n
(d m n : ‚Ñï) (n ‚â¢ 0) ((m < n) ‚à™ (m ‚â• n)) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
//By induction on (‚à™)
* (d m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  // Take (m / n) ‚âî 0
* (d m n : ‚Ñï) (n ‚â¢ 0) (m ‚â• n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //By definition
  (d m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //Apply the hypothesis to x ‚âî (m - n)
  (d m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((m - n) < m ‚Üí ((m - n) / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //(n ‚â¢ 0) => ((m - n) < m)
  (d m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((m - n) / n : ‚Ñï) ‚ä¶ (m / n : ‚Ñï)
  // take (m / n) ‚âî 1 + (m - n) / n ‚àé


(d : ‚Ñï) (n : ‚Ñï) (n ‚â¢ 0) ‚ä¶ d / n : ‚Ñï
‚àé
//By well-founded induction on d
(m n : ‚Ñï) (n ‚â¢ 0) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
//By <-dec m n
(m n : ‚Ñï) (n ‚â¢ 0) ((m < n) ‚à™ (m ‚â• n)) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
//By induction on (‚à™)
* (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  // Take (m / n) ‚âî 0
* (m n : ‚Ñï) (n ‚â¢ 0) (m ‚â• n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //By definition
  (m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //By (n ‚â§ m) ‚Üí (k : ‚Ñï) ‚®Ø (m ‚â° n + k)
  (m n k : ‚Ñï) (n ‚â¢ 0) (m ‚â° n + k) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x / n : ‚Ñï)) ‚ä¶ (m / n : ‚Ñï)
  //Contract m
  (n k : ‚Ñï) (n ‚â¢ 0) ((x : ‚Ñï) ‚Üí x < n + k ‚Üí (x / n : ‚Ñï)) ‚ä¶ ((n + k) / n : ‚Ñï)
  //Take x ‚âî k
  (n k : ‚Ñï) (n ‚â¢ 0) (k < n + k ‚Üí (k / n : ‚Ñï)) ‚ä¶ ((n + k) / n : ‚Ñï)
  //(n ‚â¢ 0) ‚Üí (k < n + k)
  (n k : ‚Ñï) (n ‚â¢ 0) (k / n : ‚Ñï) ‚ä¶ ((n + k) / n : ‚Ñï)
  //Take ((n + k) / n) ‚âî 1 + k / n ‚àé


(d : ‚Ñï) (n : ‚Ñï) (n ‚â¢ 0) ‚ä¶ d % n : ‚Ñï
‚àé
//By well-founded induction on d
(m n : ‚Ñï) (n ‚â¢ 0) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
//By <-dec m n
(m n : ‚Ñï) (n ‚â¢ 0) ((m < n) ‚à™ (m ‚â• n)) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
//By induction on (‚à™)
* (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
  //Take (m % n) ‚âî m
* (m n : ‚Ñï) (n ‚â¢ 0) (m ‚â• n) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
  //By definition
  (m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
  //By (n ‚â§ m) ‚Üí (k : ‚Ñï) ‚®Ø (m ‚â° n + k)
  (m n k : ‚Ñï) (n ‚â¢ 0) (m ‚â° n + k) ((x : ‚Ñï) ‚Üí x < m ‚Üí (x % n : ‚Ñï)) ‚ä¶ (m % n : ‚Ñï)
  //Contract m
  (n k : ‚Ñï) (n ‚â¢ 0) ((x : ‚Ñï) ‚Üí x < n + k ‚Üí (x % n : ‚Ñï)) ‚ä¶ ((n + k) % n : ‚Ñï)
  //Take x ‚âî k
  (n k : ‚Ñï) (n ‚â¢ 0) (k < n + k ‚Üí (k % n : ‚Ñï)) ‚ä¶ ((n + k) % n : ‚Ñï)
  //(n ‚â¢ 0) ‚Üí (k < n + k)
  (n k : ‚Ñï) (n ‚â¢ 0) (k % n : ‚Ñï) ‚ä¶ ((n + k) % n : ‚Ñï)
  //Take ((n + k) % n) ‚âî k % n ‚àé

(m n : ‚Ñï) (n ‚â¢ 0) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
‚àé
//By well-founded induction on m
(m n : ‚Ñï) (n ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
//By <-dec
(m n : ‚Ñï) (n ‚â¢ 0) ((m < n) ‚à™ (m ‚â• n)) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
//By induction on (‚à™)
* (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
  //By definition of m % n
  (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + m)
  //By definition of m / n
  (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° 0 * n + m)
  //0 left multiplicative annihilator
  (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° 0 + m)
  //0 left additive unit
  (m n : ‚Ñï) (n ‚â¢ 0) (m < n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° m)
  //Trivial
* (m n : ‚Ñï) (n ‚â¢ 0) (m ‚â• n) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
  //By definition
  (m n : ‚Ñï) (n ‚â¢ 0) (n ‚â§ m) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
  //
  (m n k : ‚Ñï) (n ‚â¢ 0) (m ‚â° n + k) ((k : ‚Ñï) ‚Üí k < m ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (m ‚â° (m / n) * n + (m % n))
  //Contract m
  (n k : ‚Ñï) (n ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < n + k ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (n + k ‚â° ((n + k) / n) * n + ((n + k) % n))
  //By definition of (n + k) / n
  (n k : ‚Ñï) (n ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < n + k ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (n + k ‚â° (1 + k / n) * n + ((n + k) % n))
  //By definition of (n + k) % n
  (n k : ‚Ñï) (n ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < n + k ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (n + k ‚â° (1 + k / n) * n + (k % n))
  //take k ‚âî k
  (n k : ‚Ñï) (n ‚â¢ 0) (k < n + k ‚Üí (k ‚â° (k / n) * n + (k % n))) ‚ä¶ (n + k ‚â° (1 + k / n) * n + (k % n))
  //k < n + k is true by (n ‚â¢ 0)
  (n k : ‚Ñï) (n ‚â¢ 0) (k ‚â° (k / n) * n + (k % n)) ‚ä¶ (n + k ‚â° (1 + k / n) * n + (k % n))
  //By distributive property of multiplication
  (n k : ‚Ñï) (n ‚â¢ 0) (k ‚â° (k / n) * n + (k % n)) ‚ä¶ (n + k ‚â° 1 * n + (k / n) * n + (k % n))
  //By unit property of multiplication
  (n k : ‚Ñï) (n ‚â¢ 0) (k ‚â° (k / n) * n + (k % n)) ‚ä¶ (n + k ‚â° n + (k / n) * n + (k % n))
  //By associativity
  (n k : ‚Ñï) (n ‚â¢ 0) (k ‚â° (k / n) * n + (k % n)) ‚ä¶ (n + k ‚â° n + ((k / n) * n + (k % n)))
  //By left-cancellation
  (n k : ‚Ñï) (n ‚â¢ 0) (k ‚â° (k / n) * n + (k % n)) ‚ä¶ (k ‚â° (k / n) * n + (k % n))
  //Trivial ‚àé

(x y : ‚Ñï) ‚ä¶ dist(x, y) : ‚Ñï
‚àé
//By induction on x
* (y : ‚Ñï) ‚ä¶ dist(0, y) ‚âî y : ‚Ñï
* (x y : ‚Ñï) ((y : ‚Ñï) ‚Üí dist(x, y)) ‚ä¶ dist(S x, y) : ‚Ñï
  //By case-splitting on y
  * (x : ‚Ñï) ((y : ‚Ñï) ‚Üí dist(x, y)) ‚ä¶ dist(S x, 0) ‚âî S x : ‚Ñï
  * (x y : ‚Ñï) ((y : ‚Ñï) ‚Üí dist(x, y)) ‚ä¶ dist(S x, S y) ‚âî dist(x, y) : ‚Ñï ‚àé


(a b : ‚Ñï) ‚ä¶ (a + b ‚â° 0) ‚â° ((a ‚â° 0) ‚®Ø (b ‚â° 0))
‚àé
* (a b : ‚Ñï) ‚ä¶ (a + b ‚â° 0) ‚Üí ((a ‚â° 0) ‚®Ø (b ‚â° 0))
  //By case-splitting on a
  * (b : ‚Ñï) ‚ä¶ (0 + b ‚â° 0) ‚Üí ((0 ‚â° 0) ‚®Ø (b ‚â° 0))
    //By case-splitting on b
    * (b : ‚Ñï) ‚ä¶ (0 + 0 ‚â° 0) ‚Üí ((0 ‚â° 0) ‚®Ø (0 ‚â° 0))
      //Trivial
    * (b : ‚Ñï) ‚ä¶ (0 + S b ‚â° 0) ‚Üí ((0 ‚â° 0) ‚®Ø (S b ‚â° 0))
      (b : ‚Ñï) ‚ä¶ (S b + 0 ‚â° 0) ‚Üí ((0 ‚â° 0) ‚®Ø (S b ‚â° 0))
      (b : ‚Ñï) ‚ä¶ (S (b + 0) ‚â° 0) ‚Üí ((0 ‚â° 0) ‚®Ø (S b ‚â° 0))
      //Contradiction
  * (a b : ‚Ñï) ‚ä¶ (S a + b ‚â° 0) ‚Üí ((S a ‚â° 0) ‚®Ø (b ‚â° 0))
    (a b : ‚Ñï) ‚ä¶ (S (a + b) ‚â° 0) ‚Üí ((S a ‚â° 0) ‚®Ø (b ‚â° 0))
    //Contradiction
* (a b : ‚Ñï) ‚ä¶ ((a ‚â° 0) ‚®Ø (b ‚â° 0)) ‚Üí (a + b ‚â° 0)
  (0 + 0 ‚â° 0)
  (0 ‚â° 0) ‚àé


//Left cancellation property of multiplication
(a b k : ‚Ñï) (k ‚â¢ 0) ‚ä¶ (k * a ‚â° k * b) ‚â° (a ‚â° b)
‚àé
//By propositional extensionality
* (a b k : ‚Ñï) (k ‚â¢ 0) ‚ä¶ (k * a ‚â° k * b) ‚Üí a ‚â° b
  //By case-splitting on k
  * (a b k : ‚Ñï) (0 ‚â¢ 0) ‚ä¶ (0 * a ‚â° 0 * b) ‚Üí a ‚â° b
    //Contradiction
  * (a b k : ‚Ñï) (S k ‚â¢ 0) ‚ä¶ (S k * a ‚â° S k * b) ‚Üí a ‚â° b
    //Drop (S k ‚â¢ 0)
    (a b k : ‚Ñï) ‚ä¶ (S k * a ‚â° S k * b) ‚Üí a ‚â° b
    //By induction on a
    * (a b k : ‚Ñï) ‚ä¶ (S k * 0 ‚â° S k * b) ‚Üí 0 ‚â° b
      (a b k : ‚Ñï) ‚ä¶ (0 ‚â° b + k * b) ‚Üí 0 ‚â° b
      (a b k : ‚Ñï) ‚ä¶ (0 ‚â° b) ‚®Ø (0 ‚â° k * b) ‚Üí 0 ‚â° b
      //Trivial
    * (a b k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k * S a ‚â° S k * b) ‚Üí S a ‚â° b
      //By case-splitting on b
      * (a k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k * S a ‚â° S k * 0) ‚Üí S a ‚â° 0
        (a k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S a + k * S a ‚â° 0) ‚Üí S a ‚â° 0
        (a k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S (a + k * S a) ‚â° 0) ‚Üí S a ‚â° 0
        //Contradiction
      * (a z k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k * S a ‚â° S k * S z) ‚Üí S a ‚â° S z
        (a z k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k + S k * a ‚â° S k + S k * z) ‚Üí S a ‚â° S z
        (a z k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k * a ‚â° S k * z) ‚Üí S a ‚â° S z
        (a z k : ‚Ñï) (‚àÄ b k. (S k * a ‚â° S k * b) ‚Üí a ‚â° b) ‚ä¶ (S k * a ‚â° S k * z) ‚Üí a ‚â° z
        //By induction hypothesis taking b ‚âî z, k ‚âî k
* (a b k : ‚Ñï) (k ‚â¢ 0) ‚ä¶ a ‚â° b ‚Üí k * a ‚â° k * b
  //By congruence taking f ‚âî (k *) ‚àé

//Right cancellation property of multiplication
(a b k : ‚Ñï) (k ‚â¢ 0) ‚ä¶ (a * k ‚â° b * k) ‚â° (a ‚â° b)
‚àé By commutativity of multiplication and left cancellation property of multiplication ‚àé

(a b : ‚Ñï) ‚ä¶ ((a ‚â¢ 0) ‚®Ø (b ‚â¢ 0)) ‚â° (a * b ‚â¢ 0)
‚àé
* (a b : ‚Ñï) ‚ä¶ ((a ‚â¢ 0) ‚®Ø (b ‚â¢ 0)) ‚Üí (a * b ‚â¢ 0)
  //By case-splitting on a
  * (b : ‚Ñï) ‚ä¶ ((0 ‚â¢ 0) ‚®Ø (b ‚â¢ 0)) ‚Üí (0 * b ‚â¢ 0)
    //Contradiction
  * (a b : ‚Ñï) ‚ä¶ ((S a ‚â¢ 0) ‚®Ø (b ‚â¢ 0)) ‚Üí (S a * b ‚â¢ 0)
    //Drop
    (a b : ‚Ñï) ‚ä¶ (b ‚â¢ 0) ‚Üí (S a * b ‚â¢ 0)
    //By case-slitting on b
    * (a : ‚Ñï) ‚ä¶ (0 ‚â¢ 0) ‚Üí (S a * 0 ‚â¢ 0)
      //Contradiction
    * (a b : ‚Ñï) ‚ä¶ (S b ‚â¢ 0) ‚Üí (S a * S b ‚â¢ 0)
      //Drop
      (a b : ‚Ñï) ‚ä¶ S a * S b ‚â¢ 0
      (a b : ‚Ñï) ‚ä¶ S b + a * S b ‚â¢ 0
      (a b : ‚Ñï) ‚ä¶ S (b + a * S b) ‚â¢ 0
      //By S-not-0
* (a b : ‚Ñï) ‚ä¶ (a * b ‚â¢ 0) ‚Üí ((a ‚â¢ 0) ‚®Ø (b ‚â¢ 0))
  //By case-splitting on a
  * (b : ‚Ñï) ‚ä¶ (0 * b ‚â¢ 0) ‚Üí ((0 ‚â¢ 0) ‚®Ø (b ‚â¢ 0))
    (b : ‚Ñï) ‚ä¶ (0 ‚â¢ 0) ‚Üí ((0 ‚â¢ 0) ‚®Ø (b ‚â¢ 0))
    //Contradiction
  * (a b : ‚Ñï) ‚ä¶ (S a * b ‚â¢ 0) ‚Üí ((S a ‚â¢ 0) ‚®Ø (b ‚â¢ 0))
    //By case-splitting on b
    * (a : ‚Ñï) ‚ä¶ (S a * 0 ‚â¢ 0) ‚Üí ((S a ‚â¢ 0) ‚®Ø (0 ‚â¢ 0))
      (a : ‚Ñï) ‚ä¶ (0 ‚â¢ 0) ‚Üí ((S a ‚â¢ 0) ‚®Ø (0 ‚â¢ 0))
      //Contradiction
    * (a b : ‚Ñï) ‚ä¶ (S a * S b ‚â¢ 0) ‚Üí ((S a ‚â¢ 0) ‚®Ø (S b ‚â¢ 0))
      //Drop
      (a b : ‚Ñï) ‚ä¶ (S a ‚â¢ 0) ‚®Ø (S b ‚â¢ 0)
      //By S-not-0 ‚àé


// (  a       c  )     ( a * d     c * b )
// ( ---  ‚â§  --- ) <=> ( -----  ‚â§  ----- ) <=>  (a * d  ‚â§  c * b)
// (  b       d  )     ( b * d     b * d )
(a b c d : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) ‚ä¶ (a√∑b ‚â§ c√∑d : Œ©) ‚âî a * d ‚â§ c * b


(a b : ‚Ñ§) (b ‚â¢ 0) ‚ä¶ (a√∑b ‚â§ a√∑b)
‚àé
(a b : ‚Ñ§) (b ‚â¢ 0) ‚ä¶ a * b ‚â§ a * b
//True by reflexivity of (‚â§) in ‚Ñ§ ‚àé

(a b c d e f : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) (f ‚â¢ 0) ‚ä¶ a√∑b ‚â§ c√∑d ‚Üí c√∑d ‚â§ e√∑f ‚Üí a√∑b ‚â§ e√∑f
‚àé
(a b c d e f : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) (f ‚â¢ 0) ‚ä¶ a * d ‚â§ c * b ‚Üí c * f ‚â§ e * d ‚Üí a * f ‚â§ e * b
//By (*) preserving (‚â§)
(a b c d e f : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) (f ‚â¢ 0) ‚ä¶ a * d * f ‚â§ c * b * f ‚Üí b * c * f ‚â§ b * e * d ‚Üí a * f ‚â§ e * b
//By transivitity
//a * d * f ‚â§ c * b * f ‚â§ b * e * d
(a b c d e f : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) (f ‚â¢ 0) ‚ä¶ a * d * f ‚â§ b * e * d ‚Üí a * f ‚â§ e * b
//By (*) preserving (‚â§)
(a b c d e f : ‚Ñ§) (b ‚â¢ 0) (d ‚â¢ 0) (f ‚â¢ 0) ‚ä¶ a * f ‚â§ b * e ‚Üí a * f ‚â§ e * b
//Trivial ‚àé

//TODO:
(a b k : ‚Ñï) ‚ä¶ (a + k ‚â§ b + k) ‚â° (a ‚â§ b)

//TODO:
(a b k : ‚Ñï) ‚ä¶ (a * k ‚â§ b * k) ‚â° (a ‚â§ b)

(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (a < b) ‚ä¶ gcdH(a, b) : ‚Ñï
‚àé
//By well-founded induction on b;
(a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) ‚ä¶ gcdH(a, b) : ‚Ñï
//By comparing (a, b - a)
(a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) ((a < b - a) ‚à™ (a ‚â• b - a))
  ‚ä¶ gcdH(a, b) : ‚Ñï
//By induction on (‚à™)
* (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) (a < b - a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //pick k ‚âî b - a
  (a b : ‚Ñï) (a ‚â¢ 0) (b - a < b ‚Üí (‚àÄa. (b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï)) (b ‚â¢ 0) (a < b) (a < b - a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //b - a < b is true via (a ‚â¢ 0)
  (a b : ‚Ñï) (a ‚â¢ 0) (‚àÄa. (b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //Pick a ‚âî a
  (a b : ‚Ñï) (a ‚â¢ 0) ((b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //Decide (b - a ‚â° 0)
  (a b : ‚Ñï) (a ‚â¢ 0) ((b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a) ((b - a ‚â° 0) ‚à™ (b - a ‚â¢ 0))
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //Split
  * (a b : ‚Ñï) (a ‚â¢ 0) ((b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a) (b - a ‚â° 0)
     ‚ä¶ gcdH(a, b) ‚âî a : ‚Ñï
  * (a b : ‚Ñï) (a ‚â¢ 0) ((b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a) (b - a ‚â¢ 0)
     ‚ä¶ gcdH(a, b) : ‚Ñï
    //
    (a b : ‚Ñï) (a ‚â¢ 0) (gcdH(a, b - a) : ‚Ñï) (b ‚â¢ 0) (a < b) (a < b - a) (b - a ‚â¢ 0)
     ‚ä¶ gcdH(a, b) ‚âî gcdH(a, b - a) : ‚Ñï
* (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) (a ‚â• b - a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //By definition
  (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) (b - a ‚â§ a)
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //
  (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) ((b - a ‚â° a) ‚à™ (b - a < a))
    ‚ä¶ gcdH(a, b) : ‚Ñï
  //split
  * (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) (b - a ‚â° a)
      ‚ä¶ gcdH(a, b) ‚âî a : ‚Ñï
  * (a b : ‚Ñï) (a ‚â¢ 0) ((k : ‚Ñï) ‚Üí k < b ‚Üí (‚àÄa. (k ‚â¢ 0) (a < k) ‚ä¶ gcdH(a, k) : ‚Ñï)) (b ‚â¢ 0) (a < b) (b - a < a)
      ‚ä¶ gcdH(a, b) : ‚Ñï
    //take k ‚âî a
    (a b : ‚Ñï) (a ‚â¢ 0) (a < b ‚Üí (‚àÄa'. (a ‚â¢ 0) (a' < a) ‚ä¶ gcdH(a', a) : ‚Ñï)) (b ‚â¢ 0) (a < b) (b - a < a)
       ‚ä¶ gcdH(a, b) : ‚Ñï
    //
    (a b : ‚Ñï) (a ‚â¢ 0) (‚àÄa'. (a ‚â¢ 0) (a' < a) ‚ä¶ gcdH(a', a) : ‚Ñï) (b ‚â¢ 0) (a < b) (b - a < a)
       ‚ä¶ gcdH(a, b) : ‚Ñï
    //Pick a' ‚âî b - a
    (a b : ‚Ñï) (a ‚â¢ 0) ((a ‚â¢ 0) (b - a < a) ‚ä¶ gcdH(b - a, a) : ‚Ñï) (b ‚â¢ 0) (a < b) (b - a < a)
       ‚ä¶ gcdH(a, b) : ‚Ñï
    //
    (a b : ‚Ñï) (a ‚â¢ 0) (gcdH(b - a, a) : ‚Ñï) (b ‚â¢ 0) (a < b) (b - a < a)
       ‚ä¶ gcdH(a, b) ‚âî gcdH(b - a, a) : ‚Ñï ‚àé

(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ‚ä¶ gcd(a, b) : ‚Ñï
‚àé
//By deciding (a < b)
(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (a ‚â• b)) ‚ä¶ gcd(a, b) : ‚Ñï
//
(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (b ‚â§ a)) ‚ä¶ gcd(a, b) : ‚Ñï
//
(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (b ‚â° a) ‚à™ (b < a)) ‚ä¶ gcd(a, b) : ‚Ñï
//
* (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (a < b) ‚ä¶ gcd(a, b) ‚âî gcdH(a, b) : ‚Ñï
* (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (b ‚â° a) ‚ä¶ gcd(a, b) ‚âî a : ‚Ñï
* (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (b < a) ‚ä¶ gcd(a, b) ‚âî gcdH(b, a) : ‚Ñï ‚àé


//gcd(a, b) is a divisor of a and a divisor of b
(a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ‚ä¶ (gcd(a, b) | a) ‚®Ø (gcd(a, b) | b)
‚àé
//
* (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ‚ä¶ gcd(a, b) | a
  //By deciding a < b
  (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (a ‚â• b)) ‚ä¶ gcd(a, b) | a
  //
  (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (b ‚â§ a)) ‚ä¶ gcd(a, b) | a
  //
  (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ((a < b) ‚à™ (b ‚â° a) ‚à™ (b < a)) ‚ä¶ gcd(a, b) | a
  //
  * (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (a < b) ‚ä¶ gcd(a, b) | a
    //
    (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (a < b) ‚ä¶ gcdH(a, b) | a
    //By well-founded induction on b
    (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a) ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí gcdH(a, b) | a
    //Compare a and b - a
    (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) ((a < b - a) ‚à™ (a ‚â• b - a))
      ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a)
    ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí gcdH(a, b) | a
    //Eliminate (‚à™)
    * (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) (a < b - a)
        ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a)
      ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí gcdH(a, b) | a
      //(b - a ‚â¢ 0) (a < b - a) ‚ä¶ gcdH(a, b - a) : ‚Ñï
      //Decide b - a ‚â° 0
      * (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) (a < b - a) (b - a ‚â° 0)
           ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a)
        ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí a | a
        //Trivial
      * (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) (a < b - a) (b - a ‚â¢ 0)
           ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a)
        ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí gcdH(a, b - a) | a
        //take k ‚âî b - a
        //gcdH(a, b - a) | a
        //TODO: hmmm, we should really formalise the term language and play around with terms.
        //without terms it's hard to see what "tactics" compute to
    * (a : ‚Ñï) (a ‚â¢ 0) (b : ‚Ñï) (a ‚â• b - a)
        ((k : ‚Ñï) ‚Üí k < b ‚Üí (k ‚â¢ 0) ‚Üí (a < k) ‚Üí gcdH(a, k) | a)
      ‚ä¶ (b ‚â¢ 0) ‚Üí (a < b) ‚Üí gcdH(a, b) | a


  * (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (b ‚â° a) ‚ä¶ a | a
    //Trivial
  * (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) (b < a) ‚ä¶ gcdH(b, a) | a
* (a b : ‚Ñï) (a ‚â¢ 0) (b ‚â¢ 0) ‚ä¶ gcd(a, b) | b
